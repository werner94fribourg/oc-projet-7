/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/assets/js/controller.js":
/*!*************************************!*\
  !*** ./src/assets/js/controller.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model.js */ \"./src/assets/js/model.js\");\n/* harmony import */ var _view_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view.js */ \"./src/assets/js/view.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\n/**\n * Function used to handle the submission of the search form\n * @param {HTMLDOMElement} input input text containing the search value submitted\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar handleSubmitSearchForm = function handleSubmitSearchForm(input) {\n  var entry = input.value;\n  if (entry.length < 3) {\n    input.closest('.search-form').querySelector('.invalid-feedback').innerText = 'Veuillez entrer au moins 3 caractères !';\n    input.classList.toggle('is-invalid');\n    return;\n  }\n  input.blur();\n};\n\n/**\n * Function used to handle the text typed by an user in the search form\n * @param {HTMLDOMElement} input input text containing the search value\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar handleSearchFormTextInput = function handleSearchFormTextInput(input) {\n  var entry = input.value;\n  if (entry.length < 3 && document.querySelector('.alert') === null) {\n    document.querySelector('.menu-list').innerHTML = '';\n    document.querySelectorAll('.dropdown-list').forEach(function (input) {\n      input.innerHTML = '';\n      input.style.removeProperty('grid-template-columns');\n    });\n    return;\n  }\n  if (entry.length >= 3) {\n    input.closest('.search-form').querySelector('.invalid-feedback').innerText = '';\n    input.classList.remove('is-invalid');\n  }\n  _model_js__WEBPACK_IMPORTED_MODULE_0__.getRecipesByMainEntry(entry).then(function () {\n    _view_js__WEBPACK_IMPORTED_MODULE_1__.renderRecipeList(_model_js__WEBPACK_IMPORTED_MODULE_0__.state.matchedRecipes);\n    document.querySelectorAll('.dropdown-list').forEach(function (input) {\n      input.style.setProperty('grid-template-columns', 'repeat(3, 1fr)');\n    });\n    Object.entries(_model_js__WEBPACK_IMPORTED_MODULE_0__.state.matchedSubSearch).forEach(function (entry) {\n      var _entry = _slicedToArray(entry, 2),\n        key = _entry[0],\n        value = _entry[1];\n      _view_js__WEBPACK_IMPORTED_MODULE_1__.renderSubSearchList(key, value);\n    });\n    _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerDropdownItemClick(handleDropdownItemClick);\n  })[\"catch\"](function (err) {\n    return console.error(err);\n  });\n};\n\n/**\n * Function used to handle the UI behavior when the user clicks on one of the specific buttons (Ingrédients, Appareils and Ustensiles)\n * @param {HTMLDOMElement} btn the dropdown element that was clicked\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar handleDropdownClick = function handleDropdownClick(btn) {\n  var btnGroup = btn.closest('.btn-group');\n  btnGroup.querySelector('.dropdown-menu').style.setProperty('transform', 'translate3d(0px, 0px, 0px)');\n  btnGroup.style.setProperty('max-width', \"\".concat(_model_js__WEBPACK_IMPORTED_MODULE_0__.state.mainSearch && document.querySelector('.search-form-input').value.length >= 3 ? '667' : '275', \"px\"));\n  setTimeout(function () {\n    btnGroup.classList.toggle('active');\n  }, 50);\n};\n\n/**\n * Function used to handle when an user clicks outside the active specific button on the UI : it is used to change the rendering of the button\n * @param {HTMLDOMElement} element the element that was clicked by the user\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar handleOutsideDropdownClick = function handleOutsideDropdownClick(element) {\n  var btnGroup = element.closest('.btn-group.active');\n  var active = document.querySelector('.btn-group.active');\n  if (!btnGroup && active) {\n    active.style.removeProperty('max-width');\n    active.classList.remove('active');\n    active.querySelector('.dropdown-search').value = '';\n  }\n};\n\n/**\n * Function used to handle the typing of an user inside one of the specific buttons (Ingrédients, Appareils, Ustensiles)\n * @param {HTMLDOMElement} input input text containing the search value\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar handleDropdownSearch = function handleDropdownSearch(input) {\n  var dropdownList = input.closest('.btn-group').querySelector('.dropdown-list');\n  var key = input.dataset.key;\n  var btnGroup = input.closest('.btn-group');\n  btnGroup.style.setProperty('max-width', \"\".concat(input.value === '' && _model_js__WEBPACK_IMPORTED_MODULE_0__.state.mainSearch ? '667' : '275', \"px\"));\n  dropdownList.style.setProperty('grid-template-columns', input.value === '' && _model_js__WEBPACK_IMPORTED_MODULE_0__.state.mainSearch ? 'repeat(3, 1fr)' : '1fr');\n  dropdownList.querySelectorAll('.dropdown-item').forEach(function (item) {\n    item.dataset[key].toUpperCase().includes(input.value.toUpperCase()) ? item.style.removeProperty('display') : item.style.setProperty('display', 'none');\n  });\n  if (input.value.length >= 3) input.style.removeProperty('color');\n};\n\n/**\n * Function used to handle the expected behavior of rerendering the list of recipes when the user clicks on the close button on a specific tag\n * @param {HTMLDOMElement} btn the close button that was clicked by the user\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar handleCloseAlert = function handleCloseAlert(btn) {\n  var alert = btn.closest('.alert');\n  var key = alert.dataset.key;\n  var entry = alert.dataset[key];\n  _model_js__WEBPACK_IMPORTED_MODULE_0__.removeTag(key, entry).then(function () {\n    _view_js__WEBPACK_IMPORTED_MODULE_1__.renderRecipeList(_model_js__WEBPACK_IMPORTED_MODULE_0__.state.matchedRecipes);\n    document.querySelectorAll('.dropdown-list').forEach(function (input) {\n      input.style.setProperty('grid-template-columns', '1fr');\n    });\n    Object.entries(_model_js__WEBPACK_IMPORTED_MODULE_0__.state.matchedSubSearch).forEach(function (entry) {\n      var _entry2 = _slicedToArray(entry, 2),\n        key = _entry2[0],\n        value = _entry2[1];\n      _view_js__WEBPACK_IMPORTED_MODULE_1__.renderSubSearchList(key, value);\n    });\n    _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerDropdownItemClick(handleDropdownItemClick);\n  })[\"catch\"](function (err) {\n    return console.error(err);\n  });\n};\n\n/**\n * Function used to handle the behavior when the user submits a value inside one of the specific search forms (Ingrédients, Appareils, Ustensiles)\n * @param {HTMLDOMElement} input input text containing the searched value\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar handleSubmitDropdownForm = function handleSubmitDropdownForm(input) {\n  var key = input.dataset.key;\n  if (input.value.length < 3) {\n    input.style.setProperty('color', 'red');\n    return;\n  }\n  _view_js__WEBPACK_IMPORTED_MODULE_1__.renderAlert(key, input.value);\n  _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerCloseAlert(handleCloseAlert, key, input.value);\n  _model_js__WEBPACK_IMPORTED_MODULE_0__.getRecipesBySubEntry(key, input.value).then(function () {\n    _view_js__WEBPACK_IMPORTED_MODULE_1__.renderRecipeList(_model_js__WEBPACK_IMPORTED_MODULE_0__.state.matchedRecipes);\n    document.querySelectorAll('.dropdown-list').forEach(function (input) {\n      input.style.setProperty('grid-template-columns', '1fr');\n    });\n    Object.entries(_model_js__WEBPACK_IMPORTED_MODULE_0__.state.matchedSubSearch).forEach(function (entry) {\n      var _entry3 = _slicedToArray(entry, 2),\n        key = _entry3[0],\n        value = _entry3[1];\n      _view_js__WEBPACK_IMPORTED_MODULE_1__.renderSubSearchList(key, value);\n    });\n    _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerDropdownItemClick(handleDropdownItemClick);\n  })[\"catch\"](function (err) {\n    return console.error(err);\n  });\n  document.querySelector('.logo').click();\n};\n\n/**\n * Function used to handle the click of the user on a specific element in the list of items displayed by a specific search button (Ingrédients, Appareils, Ustensiles)\n * @param {HTMLDOMElement} link value that was selected by the user\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar handleDropdownItemClick = function handleDropdownItemClick(link) {\n  var key = link.dataset.key;\n  var value = link.dataset[key];\n  var searchInput = document.querySelector(\".dropdown-search[data-key=\\\"\".concat(key, \"\\\"]\"));\n  var targetSubmit = searchInput.closest('form').querySelector('.dropdown-form-submit');\n  searchInput.value = value;\n  targetSubmit.click();\n};\n\n/**\n * Function used to initialize the whole application\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar init = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return _model_js__WEBPACK_IMPORTED_MODULE_0__.getAllRecipes();\n          case 2:\n            _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerSubmitSearchForm(handleSubmitSearchForm);\n            _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerSearchFormTextInput(handleSearchFormTextInput);\n            _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerDropdownClick(handleDropdownClick);\n            _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerOutsideDropdownClick(handleOutsideDropdownClick);\n            _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerDropdownSearch(handleDropdownSearch);\n            _view_js__WEBPACK_IMPORTED_MODULE_1__.addHandlerSubmitDropdownForm(handleSubmitDropdownForm);\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return function init() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n// Initialisation\ninit()[\"catch\"](function (err) {\n  console.error(err);\n});\n\n//# sourceURL=webpack://oc-projet-7/./src/assets/js/controller.js?");

/***/ }),

/***/ "./src/assets/js/helpers/config.js":
/*!*****************************************!*\
  !*** ./src/assets/js/helpers/config.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TIMEOUT_SEC\": () => (/* binding */ TIMEOUT_SEC),\n/* harmony export */   \"dirname\": () => (/* binding */ dirname)\n/* harmony export */ });\n/**\n * File used to store all global parameters of the application\n */\nvar TIMEOUT_SEC = 3;\nvar dirname = 'assets/js/';\n\n//# sourceURL=webpack://oc-projet-7/./src/assets/js/helpers/config.js?");

/***/ }),

/***/ "./src/assets/js/helpers/helpers.js":
/*!******************************************!*\
  !*** ./src/assets/js/helpers/helpers.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AJAX_GET\": () => (/* binding */ AJAX_GET),\n/* harmony export */   \"timeout\": () => (/* binding */ timeout)\n/* harmony export */ });\n/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config.js */ \"./src/assets/js/helpers/config.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n/**\n * Function used to create a Promise that will automatically reject/resolve after a certain specified time. It promisify the timeout behavior\n * @param {number} seconds number of seconds that will pass before the Promise rejects/resolves\n * @param {boolean} toReject boolean value used to specify if the Promise will reject (true) or resolve (false) after the time that was specified\n * @returns {Promise} a Promise that will automatically reject/resolve after the time that was specified\n * @author Werner Schmid\n */\nvar timeout = function timeout(seconds) {\n  var toReject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      toReject ? reject(new Error(\"Request took too long ! Timeout after \".concat(seconds, \" seconds\"))) : resolve();\n    }, seconds * 1000);\n  });\n};\n\n/**\n * Function used to fetch data from a specific url. It used the retry pattern so that it retries the fetch operation if it fails to retrieve the data\n * @param {string} url the url where we want to get the data\n * @returns {Object} the data fetched by calling the url\n * @author Werner Schmid\n */\nvar AJAX_GET = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {\n    var nbFails, res, data;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            nbFails = 0;\n          case 1:\n            if (false) {}\n            _context.prev = 2;\n            _context.next = 5;\n            return Promise.race([fetch(url), timeout(_config_js__WEBPACK_IMPORTED_MODULE_0__.TIMEOUT_SEC)]);\n          case 5:\n            res = _context.sent;\n            _context.next = 8;\n            return res.json();\n          case 8:\n            data = _context.sent;\n            if (res.ok) {\n              _context.next = 11;\n              break;\n            }\n            throw new Error(\"\".concat(res.status, \": \").concat(data.message));\n          case 11:\n            return _context.abrupt(\"return\", data);\n          case 14:\n            _context.prev = 14;\n            _context.t0 = _context[\"catch\"](2);\n            nbFails++;\n            console.error(\"Failed attempt \".concat(nbFails));\n            if (!(nbFails >= 3)) {\n              _context.next = 20;\n              break;\n            }\n            throw _context.t0;\n          case 20:\n            _context.next = 22;\n            return timeout(0.5, false);\n          case 22:\n            _context.next = 1;\n            break;\n          case 24:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 14]]);\n  }));\n  return function AJAX_GET(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n//# sourceURL=webpack://oc-projet-7/./src/assets/js/helpers/helpers.js?");

/***/ }),

/***/ "./src/assets/js/model.js":
/*!********************************!*\
  !*** ./src/assets/js/model.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAllRecipes\": () => (/* binding */ getAllRecipes),\n/* harmony export */   \"getRecipesByMainEntry\": () => (/* binding */ getRecipesByMainEntry),\n/* harmony export */   \"getRecipesBySubEntry\": () => (/* binding */ getRecipesBySubEntry),\n/* harmony export */   \"removeTag\": () => (/* binding */ removeTag),\n/* harmony export */   \"state\": () => (/* binding */ state)\n/* harmony export */ });\n/* harmony import */ var _helpers_helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/helpers.js */ \"./src/assets/js/helpers/helpers.js\");\n/* harmony import */ var _helpers_config_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/config.js */ \"./src/assets/js/helpers/config.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n/**\n * @param {Object} state object representing the state of the application\n * @param {boolean} state.mainSearch Value informing if the used requested a search on the global search input\n * @param {Array} state.matchedMainRecipes Array storing all the recipes matching the value searched in the main search form\n * @param {Object} state.matchedSubSearch Object containing the list of all ingredients, appliances and ustensils of the matched recipes\n * @param {Array} state.currentSearchedIngredients Array of all the ingredients actually tagged by the user in his search\n * @param {Array} state.currentSearchedAppliances Array of all the appliances actually tagged by the user in his search\n * @param {Array} state.currentSearchedUstensils Array of all the ustensils actually tagged by the user in his search\n * @param {Array} state.matchedRecipes Array storing all the recipes matching the value searched in the main search form and all the existing tags\n * @author Werner Schmid\n */\nvar state = {\n  mainSearch: false,\n  matchedMainRecipes: [],\n  matchedSubSearch: {\n    ingredient: [],\n    appliance: [],\n    ustensil: []\n  },\n  currentSearchedIngredients: [],\n  currentSearchedAppliances: [],\n  currentSearchedUstensils: [],\n  matchedRecipes: []\n};\n\n/**\n * Async function used to retrieve all the recipes from the local storage. If they aren't stored there, it will fetch it from the recipes.json file and store it there.\n * @returns {Promise} a Promise that will succeed if all the operations works smoothly\n * @author Werner Schmid\n */\nvar getAllRecipes = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var data;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            data = localStorage.getItem('recipes');\n            if (data) {\n              _context.next = 6;\n              break;\n            }\n            _context.next = 4;\n            return (0,_helpers_helpers_js__WEBPACK_IMPORTED_MODULE_0__.AJAX_GET)(_helpers_config_js__WEBPACK_IMPORTED_MODULE_1__.dirname + 'data/recipes.json');\n          case 4:\n            data = _context.sent;\n            localStorage.setItem('recipes', JSON.stringify(data));\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return function getAllRecipes() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * Function used to retrieve all existing recipes from the local storage\n * @returns {Array} the list of all stored recipes\n * @author Werner Schmid\n */\nvar getRecipesList = function getRecipesList() {\n  return JSON.parse(localStorage.getItem('recipes')).recipes;\n};\n\n/**\n * Async function used to find the recipes matching a specific entry with an algorithm using the native loops\n * @param {string} entry the entry typed by the user\n * @returns {Promise} a Promise containing all recipes matching the entry if all the operations succeeded\n * @author Werner Schmid\n */\nvar getRecipesWithNativeLoops = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(entry) {\n    var matchedMainRecipes, entryUpper, _iterator, _step, recipe, _iterator2, _step2, ingredient;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            matchedMainRecipes = []; // Iterate over the recipes\n            entryUpper = entry.toUpperCase();\n            _iterator = _createForOfIteratorHelper(getRecipesList());\n            _context2.prev = 3;\n            _iterator.s();\n          case 5:\n            if ((_step = _iterator.n()).done) {\n              _context2.next = 30;\n              break;\n            }\n            recipe = _step.value;\n            if (!(recipe.name.toUpperCase().includes(entryUpper) || recipe.description.toUpperCase().includes(entryUpper))) {\n              _context2.next = 10;\n              break;\n            }\n            matchedMainRecipes.push(recipe);\n            return _context2.abrupt(\"continue\", 28);\n          case 10:\n            // Iterate over the ingredients and add the recipe if one of them contains the string passed as parameter\n            _iterator2 = _createForOfIteratorHelper(recipe.ingredients);\n            _context2.prev = 11;\n            _iterator2.s();\n          case 13:\n            if ((_step2 = _iterator2.n()).done) {\n              _context2.next = 20;\n              break;\n            }\n            ingredient = _step2.value;\n            if (!ingredient.ingredient.toUpperCase().includes(entryUpper)) {\n              _context2.next = 18;\n              break;\n            }\n            matchedMainRecipes.push(recipe);\n            return _context2.abrupt(\"break\", 20);\n          case 18:\n            _context2.next = 13;\n            break;\n          case 20:\n            _context2.next = 25;\n            break;\n          case 22:\n            _context2.prev = 22;\n            _context2.t0 = _context2[\"catch\"](11);\n            _iterator2.e(_context2.t0);\n          case 25:\n            _context2.prev = 25;\n            _iterator2.f();\n            return _context2.finish(25);\n          case 28:\n            _context2.next = 5;\n            break;\n          case 30:\n            _context2.next = 35;\n            break;\n          case 32:\n            _context2.prev = 32;\n            _context2.t1 = _context2[\"catch\"](3);\n            _iterator.e(_context2.t1);\n          case 35:\n            _context2.prev = 35;\n            _iterator.f();\n            return _context2.finish(35);\n          case 38:\n            return _context2.abrupt(\"return\", matchedMainRecipes);\n          case 39:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[3, 32, 35, 38], [11, 22, 25, 28]]);\n  }));\n  return function getRecipesWithNativeLoops(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Async function used to retrieve all existing ingredients of a specific list of recipes\n * @param {Array} recipes array of recipes on which we want to retrieve all existing ingredients\n * @returns {Promise} a Promise containing all existing ingredients of the passed recipes if all the operations succeeded\n * @author Werner Schmid\n */\nvar getAllIngredients = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(recipes) {\n    var matchedIngredients, _iterator3, _step3, recipe, _iterator4, _step4, _loop;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            matchedIngredients = [];\n            _iterator3 = _createForOfIteratorHelper(recipes);\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                recipe = _step3.value;\n                _iterator4 = _createForOfIteratorHelper(recipe.ingredients);\n                try {\n                  _loop = function _loop() {\n                    var ingredient = _step4.value;\n                    if (!matchedIngredients.some(function (entry) {\n                      return entry.toUpperCase() === ingredient.ingredient.toUpperCase();\n                    })) matchedIngredients.push(ingredient.ingredient);\n                  };\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    _loop();\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            return _context3.abrupt(\"return\", matchedIngredients);\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return function getAllIngredients(_x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\n/**\n * Async function used to retrieve all existing appliances of a specific list of recipes\n * @param {Array} recipes array of recipes on which we want to retrieve all existing appliances\n * @returns {Promise} a Promise containing all existing appliances of the passed recipes if all the operations succeeded\n * @author Werner Schmid\n */\nvar getAllAppliances = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(recipes) {\n    var matchedAppliances, _iterator5, _step5, recipe;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            matchedAppliances = [];\n            _iterator5 = _createForOfIteratorHelper(recipes);\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                recipe = _step5.value;\n                matchedAppliances.push(recipe.appliance);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n            return _context4.abrupt(\"return\", matchedAppliances);\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return function getAllAppliances(_x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\n/**\n * Async function used to retrieve all existing ustensils of a specific list of recipes\n * @param {Array} recipes array of recipes on which we want to retrieve all existing ustensils\n * @returns {Promise} a Promise containing all existing ustensils of the passed recipes if all the operations succeeded\n * @author Werner Schmid\n */\nvar getAllUstensils = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(recipes) {\n    var matchedUstensils, _iterator6, _step6, recipe, _iterator7, _step7, _loop2;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            matchedUstensils = [];\n            _iterator6 = _createForOfIteratorHelper(recipes);\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                recipe = _step6.value;\n                _iterator7 = _createForOfIteratorHelper(recipe.ustensils);\n                try {\n                  _loop2 = function _loop2() {\n                    var ustensil = _step7.value;\n                    if (!matchedUstensils.some(function (entry) {\n                      return entry.toUpperCase() === ustensil.toUpperCase();\n                    })) matchedUstensils.push(ustensil);\n                  };\n                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                    _loop2();\n                  }\n                } catch (err) {\n                  _iterator7.e(err);\n                } finally {\n                  _iterator7.f();\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n            return _context5.abrupt(\"return\", matchedUstensils);\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return function getAllUstensils(_x4) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\n/**\n * Function used to modify the value of the mainSearch parameter of the state object\n * @param {boolean} value new value of the mainSearch parameter of the state object\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar setMainSearch = function setMainSearch(value) {\n  state.mainSearch = value;\n};\n\n/**\n * Async function used to update the state.mainSearch value and the list of ingredients, appliances and ustensiles in the state.matchedSubSearch object. Those parameters will be used by the UI to update its displayed list of elements\n * @param {Array} recipes array of recipes we use to update the list of ingredients, appliances and ustensils in the state.matchedSubSearch object\n * @param {boolean} mainSearchValue new value of the state.mainSearch.\n * @returns {Promise} a Promise that will succeed if all the operations works smoothly\n * @author Werner Schmid\n */\nvar setSearchProperties = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(recipes) {\n    var mainSearchValue,\n      matchedSubSearch,\n      _yield$Promise$all,\n      _yield$Promise$all2,\n      _args6 = arguments;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            mainSearchValue = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : true;\n            matchedSubSearch = state.matchedSubSearch;\n            setMainSearch(mainSearchValue);\n            _context6.next = 5;\n            return Promise.all([getAllIngredients(recipes), getAllAppliances(recipes), getAllUstensils(recipes)]);\n          case 5:\n            _yield$Promise$all = _context6.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);\n            matchedSubSearch.ingredient = _yield$Promise$all2[0];\n            matchedSubSearch.appliance = _yield$Promise$all2[1];\n            matchedSubSearch.ustensil = _yield$Promise$all2[2];\n          case 10:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return function setSearchProperties(_x5) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\n/**\n * Async function used to filter the recipes matching the main search (state.matchedMainRecipes) so that state.matchedRecipes contains only the recipes matching all the current active tags (e.g. state.currentSearchedIngredients)\n * @returns {Promise} a Promise that will succeed if all the operations works smoothly\n * @author Werner Schmid\n */\nvar filterMainRecipeList = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            state.matchedRecipes = state.matchedMainRecipes;\n            if (!(state.currentSearchedIngredients.length !== 0)) {\n              _context7.next = 5;\n              break;\n            }\n            _context7.next = 4;\n            return getAllRecipesByIngredients(state.currentSearchedIngredients);\n          case 4:\n            state.matchedRecipes = _context7.sent;\n          case 5:\n            if (!(state.currentSearchedAppliances.length !== 0)) {\n              _context7.next = 9;\n              break;\n            }\n            _context7.next = 8;\n            return getAllRecipesByAppliances(state.currentSearchedAppliances);\n          case 8:\n            state.matchedRecipes = _context7.sent;\n          case 9:\n            if (!(state.currentSearchedUstensils.length !== 0)) {\n              _context7.next = 13;\n              break;\n            }\n            _context7.next = 12;\n            return getAllRecipesByUstensils(state.currentSearchedUstensils);\n          case 12:\n            state.matchedRecipes = _context7.sent;\n          case 13:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return function filterMainRecipeList() {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\n/**\n * Function used to retrieve all the recipes based by the entry passed by the user and the current active tags\n * @param {string} entry the entry typed by the user\n * @returns {Promise} a Promise that will succeed if all the operations works smoothly\n * @author Werner Schmid\n */\nvar getRecipesByMainEntry = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(entry) {\n    var recipes;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return getRecipesWithNativeLoops(entry);\n          case 2:\n            recipes = _context8.sent;\n            state.matchedMainRecipes = recipes;\n            _context8.next = 6;\n            return filterMainRecipeList();\n          case 6:\n            _context8.next = 8;\n            return setSearchProperties(state.matchedRecipes);\n          case 8:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n  return function getRecipesByMainEntry(_x6) {\n    return _ref8.apply(this, arguments);\n  };\n}();\n\n/**\n * Function used to return the list of recipes matching the current typed entry if a search was already made and all existing recipes otherwise\n * @returns {Array} a list of recipes\n * @author Werner Schmid\n */\nvar getRecipesSubList = function getRecipesSubList() {\n  return state.matchedMainRecipes.length !== 0 ? state.matchedMainRecipes : getRecipesList();\n};\n\n/**\n * Function used to filter a list of recipes based on a certain type (ingredient, appliance, ustensil) and a list of entries\n * @param {Array} recipes list of recipes on which we want to apply the filter\n * @param {string} type type of element on which we want to check if the recipe matches the condition (ingredient, appliance, ustensil)\n * @param {Function} compFunc function used to compare a recipe based on an ingredient, appliance and ustensil\n * @param {Array} entries entries on which we want to compare if an element matches a condition\n * @returns {Promise} a Promise containing the array of filtered recipes if all the operations works smoothly\n * @author Werner Schmid\n */\nvar getAllRecipesByType = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(recipes, type, compFunc, entries) {\n    var matchedItemsRecipes, _iterator8, _step8, recipe, comps, iterType, _iterator9, _step9, item, i, _iterator10, _step10, entry;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            matchedItemsRecipes = [];\n            _iterator8 = _createForOfIteratorHelper(recipes);\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                recipe = _step8.value;\n                comps = new Array(entries.length).fill(false);\n                iterType = !Array.isArray(recipe[type]) ? [recipe[type]] : recipe[type];\n                _iterator9 = _createForOfIteratorHelper(iterType);\n                try {\n                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                    item = _step9.value;\n                    i = 0;\n                    _iterator10 = _createForOfIteratorHelper(entries);\n                    try {\n                      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                        entry = _step10.value;\n                        if (!comps[i]) comps[i] = compFunc(item, entry, matchedItemsRecipes, recipe);\n                        i++;\n                      }\n                    } catch (err) {\n                      _iterator10.e(err);\n                    } finally {\n                      _iterator10.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator9.e(err);\n                } finally {\n                  _iterator9.f();\n                }\n                if (comps.reduce(function (acc, curr) {\n                  return acc * curr;\n                }, true)) matchedItemsRecipes.push(recipe);\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n            return _context9.abrupt(\"return\", matchedItemsRecipes);\n          case 4:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  return function getAllRecipesByType(_x7, _x8, _x9, _x10) {\n    return _ref9.apply(this, arguments);\n  };\n}();\n\n/**\n * Function used to filter a list of recipes based on its ingredients and a list of entries\n * @param {Array} entries entries on which we want to compare if an element matches a condition\n * @returns {Promise} a Promise containing the array of filtered recipes if all the operations works smoothly\n * @author Werner Schmid\n */\nvar getAllRecipesByIngredients = /*#__PURE__*/function () {\n  var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(entries) {\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            return _context10.abrupt(\"return\", getAllRecipesByType(getRecipesSubList(), 'ingredients', function (ingredient, entry) {\n              return ingredient.ingredient.toUpperCase().includes(entry.toUpperCase());\n            }, entries));\n          case 1:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n  return function getAllRecipesByIngredients(_x11) {\n    return _ref10.apply(this, arguments);\n  };\n}();\n\n/**\n * Function used to filter a list of recipes based on its appliances and a list of entries\n * @param {Array} entries entries on which we want to compare if an element matches a condition\n * @returns {Promise} a Promise containing the array of filtered recipes if all the operations works smoothly\n * @author Werner Schmid\n */\nvar getAllRecipesByAppliances = /*#__PURE__*/function () {\n  var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(entries) {\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            return _context11.abrupt(\"return\", getAllRecipesByType(getRecipesSubList(), 'appliance', function (appliance, entry) {\n              return appliance.toUpperCase().includes(entry.toUpperCase());\n            }, entries));\n          case 1:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return function getAllRecipesByAppliances(_x12) {\n    return _ref11.apply(this, arguments);\n  };\n}();\n\n/**\n * Async function used to filter a list of recipes based on its ustensils and a list of entries\n * @param {Array} entries entries on which we want to compare if an element matches a condition\n * @returns {Promise} a Promise containing the array of filtered recipes if all the operations works smoothly\n * @author Werner Schmid\n */\nvar getAllRecipesByUstensils = /*#__PURE__*/function () {\n  var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(entries) {\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            return _context12.abrupt(\"return\", getAllRecipesByType(getRecipesSubList(), 'ustensils', function (ustensil, entry) {\n              return ustensil.toUpperCase().includes(entry.toUpperCase());\n            }, entries));\n          case 1:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  return function getAllRecipesByUstensils(_x13) {\n    return _ref12.apply(this, arguments);\n  };\n}();\n\n/**\n * Async function used to add a new entry into the searched tags and to refilter the matched recipes\n * @param {string} key the type of the tag we want to add (ingredient, ustensil, appliance)\n * @param {string} entry the entry submitted by the user\n * @returns {Promise} a Promise that will succeed if all the operations works smoothly\n * @author Werner Schmid\n */\nvar getRecipesBySubEntry = /*#__PURE__*/function () {\n  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(key, entry) {\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.t0 = key;\n            _context13.next = _context13.t0 === 'ingredient' ? 3 : _context13.t0 === 'appliance' ? 8 : _context13.t0 === 'ustensil' ? 13 : 18;\n            break;\n          case 3:\n            state.currentSearchedIngredients.push(entry);\n            _context13.next = 6;\n            return getAllRecipesByIngredients(state.currentSearchedIngredients);\n          case 6:\n            state.matchedRecipes = _context13.sent;\n            return _context13.abrupt(\"break\", 18);\n          case 8:\n            state.currentSearchedAppliances.push(entry);\n            _context13.next = 11;\n            return getAllRecipesByAppliances(state.currentSearchedAppliances);\n          case 11:\n            state.matchedRecipes = _context13.sent;\n            return _context13.abrupt(\"break\", 18);\n          case 13:\n            state.currentSearchedUstensils.push(entry);\n            _context13.next = 16;\n            return getAllRecipesByUstensils(state.currentSearchedUstensils);\n          case 16:\n            state.matchedRecipes = _context13.sent;\n            return _context13.abrupt(\"break\", 18);\n          case 18:\n            _context13.next = 20;\n            return setSearchProperties(state.matchedRecipes, false);\n          case 20:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return function getRecipesBySubEntry(_x14, _x15) {\n    return _ref13.apply(this, arguments);\n  };\n}();\n\n/**\n * Async function used to remove an entry fro the searched tags and to refilter the matched recipes\n * @param {string} key the type of the tag we want to remove (ingredient, ustensil, appliance)\n * @param {string} entry the entry that has to be removed\n * @returns {Promise} a Promise that will succeed if all the operations works smoothly\n * @author Werner Schmid\n */\nvar removeTag = /*#__PURE__*/function () {\n  var _ref14 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(key, entry) {\n    var arr, index;\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            _context14.t0 = key;\n            _context14.next = _context14.t0 === 'ingredient' ? 3 : _context14.t0 === 'appliance' ? 5 : _context14.t0 === 'ustensil' ? 7 : 9;\n            break;\n          case 3:\n            arr = state.currentSearchedIngredients;\n            return _context14.abrupt(\"break\", 9);\n          case 5:\n            arr = state.currentSearchedAppliances;\n            return _context14.abrupt(\"break\", 9);\n          case 7:\n            arr = state.currentSearchedUstensils;\n            return _context14.abrupt(\"break\", 9);\n          case 9:\n            index = arr.indexOf(entry);\n            if (index > -1) {\n              arr.splice(index, 1);\n            }\n            _context14.next = 13;\n            return filterMainRecipeList();\n          case 13:\n            _context14.next = 15;\n            return setSearchProperties(state.matchedRecipes, false);\n          case 15:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14);\n  }));\n  return function removeTag(_x16, _x17) {\n    return _ref14.apply(this, arguments);\n  };\n}();\n\n//# sourceURL=webpack://oc-projet-7/./src/assets/js/model.js?");

/***/ }),

/***/ "./src/assets/js/view.js":
/*!*******************************!*\
  !*** ./src/assets/js/view.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addHandlerCloseAlert\": () => (/* binding */ addHandlerCloseAlert),\n/* harmony export */   \"addHandlerDropdownClick\": () => (/* binding */ addHandlerDropdownClick),\n/* harmony export */   \"addHandlerDropdownItemClick\": () => (/* binding */ addHandlerDropdownItemClick),\n/* harmony export */   \"addHandlerDropdownSearch\": () => (/* binding */ addHandlerDropdownSearch),\n/* harmony export */   \"addHandlerOutsideDropdownClick\": () => (/* binding */ addHandlerOutsideDropdownClick),\n/* harmony export */   \"addHandlerSearchFormTextInput\": () => (/* binding */ addHandlerSearchFormTextInput),\n/* harmony export */   \"addHandlerSubmitDropdownForm\": () => (/* binding */ addHandlerSubmitDropdownForm),\n/* harmony export */   \"addHandlerSubmitSearchForm\": () => (/* binding */ addHandlerSubmitSearchForm),\n/* harmony export */   \"renderAlert\": () => (/* binding */ renderAlert),\n/* harmony export */   \"renderRecipeList\": () => (/* binding */ renderRecipeList),\n/* harmony export */   \"renderSubSearchList\": () => (/* binding */ renderSubSearchList)\n/* harmony export */ });\n/**\n * @param {Object} alertColors object used to store all alert color classes of the tags related to the type of it\n * @param {string} alertColors.ingredient alert color class related to the ingredients\n * @param {string} alertColors.appliance alert color class related to the appliances\n * @param {string} alertColors.ustensil alert color class related to the ustensils\n * @author Werner Schmid\n */\nvar alertColors = {\n  ingredient: 'primary',\n  appliance: 'success',\n  ustensil: 'danger'\n};\n\n/**\n * Function used to add an event listener when the user is submitting the main search form\n * @param {Function} handler handler function that will be called when the event is triggered\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar addHandlerSubmitSearchForm = function addHandlerSubmitSearchForm(handler) {\n  document.querySelector('.search-form').addEventListener('submit', function (event) {\n    event.preventDefault();\n    handler(event.target.querySelector('.form-control'));\n  });\n};\n\n/**\n * Function used to add an event listener when the user is typing in the main search input\n * @param {Function} handler handler function that will be called when the event is triggered\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar addHandlerSearchFormTextInput = function addHandlerSearchFormTextInput(handler) {\n  document.querySelector('.search-form-input').addEventListener('input', function (event) {\n    handler(event.target);\n  });\n};\n\n/**\n * Function used to add an event listener when the user is clicking one of the subsearching buttons\n * @param {Function} handler handler function that will be called when the event is triggered\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar addHandlerDropdownClick = function addHandlerDropdownClick(handler) {\n  document.querySelectorAll('.dropdown-toggle').forEach(function (input) {\n    input.addEventListener('click', function (event) {\n      event.preventDefault();\n      handler(event.target);\n    });\n  });\n};\n\n/**\n * Function used to add an event listener when the user is clicking outside the active subsearching button\n * @param {Function} handler handler function that will be called when the event is triggered\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar addHandlerOutsideDropdownClick = function addHandlerOutsideDropdownClick(handler) {\n  window.addEventListener('click', function (event) {\n    handler(event.target);\n  });\n};\n\n/**\n * Function used to add an event listener when the user is submitting one of the subsearching forms\n * @param {Function} handler handler function that will be called when the event is triggered\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar addHandlerSubmitDropdownForm = function addHandlerSubmitDropdownForm(handler) {\n  document.querySelectorAll('.dropdown-form').forEach(function (input) {\n    input.addEventListener('submit', function (event) {\n      event.preventDefault();\n      handler(event.target.querySelector('.dropdown-search'));\n    });\n  });\n};\n\n/**\n * Function used to add an event listener when the user is typing in the input of one of the subsearching forms\n * @param {Function} handler handler function that will be called when the event is triggered\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar addHandlerDropdownSearch = function addHandlerDropdownSearch(handler) {\n  document.querySelectorAll('.dropdown-search').forEach(function (input) {\n    input.addEventListener('keyup', function (event) {\n      handler(event.target);\n    });\n  });\n};\n\n/**\n * Function used to add an event listener when the user clicks one of the specific tags\n * @param {Function} handler handler function that will be called when the event is triggered\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar addHandlerDropdownItemClick = function addHandlerDropdownItemClick(handler) {\n  document.querySelectorAll('.dropdown-item').forEach(function (input) {\n    input.addEventListener('click', function (event) {\n      event.preventDefault();\n      event.stopPropagation();\n      handler(event.target);\n    });\n  });\n};\n\n/**\n * Function used to add an event listener when the user clicks the close button of one of the tags\n * @param {Function} handler handler function that will be called when the event is triggered\n * @param {string} type type of the tag on which we want to add the event handler\n * @param {string} value value displayed of the tag on which we want to add the event handler\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar addHandlerCloseAlert = function addHandlerCloseAlert(handler, type, value) {\n  document.querySelector(\".alert[data-\".concat(type, \"=\\\"\").concat(value, \"\\\"] .btn-close\")).addEventListener('click', function (event) {\n    handler(event.target);\n  });\n};\n\n/**\n * Function used to render the list of recipes in the interface\n * @param {Array} data array of recipes we want to display in the interface\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar renderRecipeList = function renderRecipeList(data) {\n  var markup = data.length === 0 ? \"<p class=\\\"not-found-message\\\">Aucune recette ne correspond \\xE0 votre crit\\xE8re\\u2026 vous pouvez chercher \\xAB tarte aux pommes \\xBB, \\xAB poisson \\xBB, etc.</p>\" : data.map(function (recipe) {\n    return \"\\n          <div class=\\\"card\\\">\\n            <div class=\\\"card-img-top\\\"></div>\\n            <!--<img src=\\\"/\\\" class=\\\"card-img-top\\\" alt=\\\"...\\\" />-->\\n            <div class=\\\"card-body\\\">\\n              <div class=\\\"row first-row\\\">\\n                <h5 class=\\\"card-title col\\\">\".concat(recipe.name, \"</h5>\\n                <p class=\\\"card-description col-4\\\">\\n                  <svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"32\\\" height=\\\"32\\\" viewBox=\\\"0 0 32 32\\\">\\n                    <title>clock</title>\\n                    <path d=\\\"M20.586 23.414l-6.586-6.586v-8.828h4v7.172l5.414 5.414zM16 0c-8.837 0-16 7.163-16 16s7.163 16 16 16 16-7.163 16-16-7.163-16-16-16zM16 28c-6.627 0-12-5.373-12-12s5.373-12 12-12c6.627 0 12 5.373 12 12s-5.373 12-12 12z\\\"></path>\\n                  </svg>\\n                  \").concat(recipe.time, \" min\\n                </p>\\n              </div>\\n              <div class=\\\"row\\\">\\n                <ul class=\\\"card-list col\\\">\\n                  \").concat(recipe.ingredients.map(function (ingredient) {\n      return \"\\n                      <li class=\\\"card-list-item\\\">\\n                        <span class=\\\"card-list-ingredient\\\">\\n                        \".concat(ingredient.ingredient).concat(ingredient.quantity ? ': ' : ' ', \" \\n                        </span>\\n                        \").concat(ingredient.quantity ? \"<span class=\\\"card-list-quantity\\\">\\n                              \".concat(ingredient.quantity).concat(ingredient.unit ? ingredient.unit : '', \"\\n                            </span>\") : '', \"\\n                      </li>\\n                      \");\n    }).join('\\n'), \"\\n                </ul>\\n                <p class=\\\"card-text col\\\">\\n                  \").concat(recipe.description, \"\\n                </p>\\n              </div>\\n            </div>\\n          </div>\\n  \");\n  }).join('\\n');\n  document.querySelector('.menu-list').innerHTML = markup;\n};\n\n/**\n * Function used to render the list of tags (ingredients, appliances, ustensils) into its respective dropdown list\n * @param {string} type type of the list of tags we want to display\n * @param {Array} data array of tags (ingredients, appliances, ustensils) we want to display in the interface\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar renderSubSearchList = function renderSubSearchList(type, data) {\n  var markup = data.map(function (item) {\n    return \"\\n      <a class=\\\"dropdown-item\\\" href=\\\"#\\\" data-key=\\\"\".concat(type, \"\\\" data-\").concat(type, \"=\\\"\").concat(item, \"\\\">\").concat(item, \"</a>\\n    \");\n  }).join('\\n');\n  document.querySelector(\".\".concat(type, \"-dropdown .dropdown-list\")).innerHTML = markup;\n};\n\n/**\n * Function used to display a new alert tag into the page\n * @param {string} type type of the new alert tag we want to display\n * @param {string} value value of the tag we want to display\n * @returns {undefined} no specific value returned\n * @author Werner Schmid\n */\nvar renderAlert = function renderAlert(type, value) {\n  if (document.querySelector(\".alert[data-\".concat(type, \"=\\\"\").concat(value, \"\\\"]\")) !== null) return;\n  var markup = \"\\n  <div class=\\\"alert alert-\".concat(alertColors[type], \" alert-dismissible fade show\\\" role=\\\"alert\\\" data-key=\\\"\").concat(type, \"\\\" data-\").concat(type, \"=\\\"\").concat(value, \"\\\">\\n    \").concat(value, \"\\n    <button type=\\\"button\\\" class=\\\"btn-close border border-white rounded-circle\\\" data-bs-dismiss=\\\"alert\\\" aria-label=\\\"Close\\\"></button>\\n  </div>\\n  \");\n  document.querySelector('.alert-row').insertAdjacentHTML('beforeend', markup);\n};\n\n//# sourceURL=webpack://oc-projet-7/./src/assets/js/view.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/assets/js/controller.js");
/******/ 	
/******/ })()
;